//! Core types for the memory store.

use std::path::PathBuf;

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// ─────────────────────────────────────────────────────────────────────────────
// Memory Types
// ─────────────────────────────────────────────────────────────────────────────

/// Unique identifier for a memory.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct MemoryId(pub Uuid);

impl MemoryId {
    /// Generate a new random memory ID.
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }

    /// Create from an existing UUID.
    pub fn from_uuid(uuid: Uuid) -> Self {
        Self(uuid)
    }

    /// Parse from a string.
    pub fn parse(s: &str) -> Result<Self, uuid::Error> {
        Ok(Self(Uuid::parse_str(s)?))
    }
}

impl Default for MemoryId {
    fn default() -> Self {
        Self::new()
    }
}

impl std::fmt::Display for MemoryId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Type of content stored in a memory.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ContentType {
    /// User message from a conversation.
    UserMessage,
    /// Assistant response.
    AssistantMessage,
    /// Tool invocation and result.
    ToolUse,
    /// File content that was indexed.
    FileContent,
    /// User note or annotation.
    Note,
    /// Extracted fact or knowledge.
    Fact,
    /// Web page content.
    WebContent,
    /// Internal reasoning / thinking.
    Thought,
    /// Session summary generated by the indexing pipeline.
    Summary,
}

impl ContentType {
    /// Get the string representation for database storage.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::UserMessage => "user_message",
            Self::AssistantMessage => "assistant_message",
            Self::ToolUse => "tool_use",
            Self::FileContent => "file_content",
            Self::Note => "note",
            Self::Fact => "fact",
            Self::WebContent => "web_content",
            Self::Thought => "thought",
            Self::Summary => "summary",
        }
    }

    /// Parse from database string.
    pub fn from_str(s: &str) -> Option<Self> {
        match s {
            "user_message" => Some(Self::UserMessage),
            "assistant_message" => Some(Self::AssistantMessage),
            "tool_use" => Some(Self::ToolUse),
            "file_content" => Some(Self::FileContent),
            "note" => Some(Self::Note),
            "fact" => Some(Self::Fact),
            "web_content" => Some(Self::WebContent),
            "thought" => Some(Self::Thought),
            "summary" => Some(Self::Summary),
            _ => None,
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Confidence Types
// ─────────────────────────────────────────────────────────────────────────────

/// How a fact or memory was established.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ConfidenceSource {
    /// User explicitly stated it (e.g., "my API key is X").
    Stated,
    /// Derived from observed behavior (e.g., user always uses Groq).
    Observed,
    /// Extracted by the indexing pipeline.
    Inferred,
    /// Set by the system (e.g., configuration values).
    System,
}

impl ConfidenceSource {
    /// Get the string representation for database storage.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Stated => "stated",
            Self::Observed => "observed",
            Self::Inferred => "inferred",
            Self::System => "system",
        }
    }

    /// Parse from database string.
    pub fn from_db_str(s: &str) -> Option<Self> {
        match s {
            "stated" => Some(Self::Stated),
            "observed" => Some(Self::Observed),
            "inferred" => Some(Self::Inferred),
            "system" => Some(Self::System),
            _ => None,
        }
    }
}

/// Confidence metadata for a memory.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryConfidence {
    /// How the fact was established.
    pub source: ConfidenceSource,
    /// Number of times this fact was reinforced (referenced/confirmed).
    pub reinforcement_count: u32,
    /// Whether this fact has been contradicted by newer information.
    pub superseded: bool,
    /// ID of the memory that superseded this one (if any).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub superseded_by: Option<MemoryId>,
    /// Last time this memory was accessed/referenced.
    pub last_accessed: DateTime<Utc>,
    /// Computed confidence score (0.0 - 1.0).
    pub score: f32,
}

impl Default for MemoryConfidence {
    fn default() -> Self {
        Self {
            source: ConfidenceSource::Inferred,
            reinforcement_count: 0,
            superseded: false,
            superseded_by: None,
            last_accessed: Utc::now(),
            score: 1.0,
        }
    }
}

impl MemoryConfidence {
    /// Create confidence with a specific source.
    pub fn with_source(source: ConfidenceSource) -> Self {
        Self {
            source,
            ..Default::default()
        }
    }

    /// Compute a composite confidence score from all factors.
    ///
    /// Score formula:
    /// 1. Base score from source type
    /// 2. Multiply by reinforcement boost: `min(1.0 + 0.1 * count, cap)`
    /// 3. Multiply by staleness factor (1.0 for recent, decays linearly to floor)
    /// 4. Superseded memories always return 0.0
    pub fn compute_score(&self, params: &ConfidenceParams) -> f32 {
        if self.superseded {
            return 0.0;
        }

        let base = self.source.base_score();

        let reinforcement_boost =
            (1.0 + 0.1 * self.reinforcement_count as f32).min(params.reinforcement_cap);

        let days_since = (Utc::now() - self.last_accessed).num_days().max(0) as f32;
        let staleness = if days_since <= params.fresh_days {
            1.0
        } else {
            let decay_range = params.staleness_days - params.fresh_days;
            if decay_range <= 0.0 {
                params.staleness_floor
            } else {
                let progress = ((days_since - params.fresh_days) / decay_range).min(1.0);
                1.0 - progress * (1.0 - params.staleness_floor)
            }
        };

        (base * reinforcement_boost * staleness).clamp(0.0, 1.0)
    }
}

impl ConfidenceSource {
    /// Base confidence score for this source type.
    pub fn base_score(&self) -> f32 {
        match self {
            Self::Stated => 1.0,
            Self::System => 0.9,
            Self::Observed => 0.7,
            Self::Inferred => 0.5,
        }
    }
}

/// Configurable parameters for confidence scoring.
#[derive(Debug, Clone)]
pub struct ConfidenceParams {
    /// Number of days before staleness decay begins.
    pub fresh_days: f32,
    /// Number of days at which staleness reaches the floor.
    pub staleness_days: f32,
    /// Minimum staleness multiplier (floor).
    pub staleness_floor: f32,
    /// Maximum reinforcement multiplier.
    pub reinforcement_cap: f32,
}

impl Default for ConfidenceParams {
    fn default() -> Self {
        Self {
            fresh_days: 30.0,
            staleness_days: 365.0,
            staleness_floor: 0.3,
            reinforcement_cap: 1.5,
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Citation Types
// ─────────────────────────────────────────────────────────────────────────────

/// Citation tracking for memory provenance.
///
/// Citations record where a memory came from, enabling verification and
/// staleness detection. Each variant captures source-specific metadata.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Citation {
    /// From a conversation session.
    Session {
        /// The session this memory was extracted from.
        session_id: String,
        /// Message index within the session (0-based).
        message_index: usize,
        /// When the message occurred.
        timestamp: DateTime<Utc>,
    },

    /// From a file read by the agent.
    File {
        /// Absolute path to the source file.
        path: PathBuf,
        /// Starting line number (1-based, if applicable).
        #[serde(skip_serializing_if = "Option::is_none")]
        line_start: Option<usize>,
        /// Ending line number (1-based, if applicable).
        #[serde(skip_serializing_if = "Option::is_none")]
        line_end: Option<usize>,
        /// Git commit hash at extraction time (if in a repo).
        #[serde(skip_serializing_if = "Option::is_none")]
        commit_hash: Option<String>,
        /// SHA-256 hash of file content at extraction time.
        #[serde(skip_serializing_if = "Option::is_none")]
        content_hash: Option<String>,
        /// File modification time at extraction.
        #[serde(skip_serializing_if = "Option::is_none")]
        mtime: Option<DateTime<Utc>>,
    },

    /// From a web fetch.
    Web {
        /// The URL that was fetched.
        url: String,
        /// When the content was fetched.
        fetched_at: DateTime<Utc>,
        /// Page title if available.
        #[serde(skip_serializing_if = "Option::is_none")]
        title: Option<String>,
        /// SHA-256 hash of content at fetch time.
        #[serde(skip_serializing_if = "Option::is_none")]
        content_hash: Option<String>,
        /// HTTP ETag header for cache validation.
        #[serde(skip_serializing_if = "Option::is_none")]
        etag: Option<String>,
    },

    /// User-stated fact (explicit input, highest confidence).
    User {
        /// Session where the user stated this.
        session_id: String,
        /// When the user stated it.
        stated_at: DateTime<Utc>,
    },

    /// System-derived (inferred, computed, aggregated).
    System {
        /// When this was derived.
        derived_at: DateTime<Utc>,
        /// Method used (e.g., "graph_inference", "llm_extraction", "summarization").
        method: String,
    },
}

impl Citation {
    /// Create a session citation.
    pub fn session(session_id: impl Into<String>, message_index: usize) -> Self {
        Self::Session {
            session_id: session_id.into(),
            message_index,
            timestamp: Utc::now(),
        }
    }

    /// Create a file citation.
    pub fn file(path: impl Into<PathBuf>) -> Self {
        Self::File {
            path: path.into(),
            line_start: None,
            line_end: None,
            commit_hash: None,
            content_hash: None,
            mtime: None,
        }
    }

    /// Create a web citation.
    pub fn web(url: impl Into<String>) -> Self {
        Self::Web {
            url: url.into(),
            fetched_at: Utc::now(),
            title: None,
            content_hash: None,
            etag: None,
        }
    }

    /// Create a user citation.
    pub fn user(session_id: impl Into<String>) -> Self {
        Self::User {
            session_id: session_id.into(),
            stated_at: Utc::now(),
        }
    }

    /// Create a system citation.
    pub fn system(method: impl Into<String>) -> Self {
        Self::System {
            derived_at: Utc::now(),
            method: method.into(),
        }
    }

    /// Get the citation type as a string.
    pub fn citation_type(&self) -> &'static str {
        match self {
            Self::Session { .. } => "session",
            Self::File { .. } => "file",
            Self::Web { .. } => "web",
            Self::User { .. } => "user",
            Self::System { .. } => "system",
        }
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Staleness Types
// ─────────────────────────────────────────────────────────────────────────────

/// Staleness status for a memory's citation source.
///
/// Used during recall to flag memories whose sources may have changed.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "status", rename_all = "snake_case")]
#[derive(Default)]
pub enum Staleness {
    /// Source unchanged or recently verified.
    Fresh,

    /// Source may have changed since extraction.
    PotentiallyStale {
        /// Reason for staleness (e.g., "file_modified", "age_exceeded", "mtime_changed").
        reason: String,
        /// When the source was last verified.
        #[serde(skip_serializing_if = "Option::is_none")]
        last_verified: Option<DateTime<Utc>>,
    },

    /// Source confirmed changed; memory needs re-extraction.
    Invalidated {
        /// Reason for invalidation.
        reason: String,
        /// When invalidation was detected.
        detected_at: DateTime<Utc>,
    },

    /// Unable to check staleness (source unavailable, no citation, etc.).
    #[default]
    Unknown,
}

impl Staleness {
    /// Check if this status indicates fresh data.
    pub fn is_fresh(&self) -> bool {
        matches!(self, Self::Fresh)
    }

    /// Check if this status indicates potential or confirmed staleness.
    pub fn is_stale(&self) -> bool {
        matches!(
            self,
            Self::PotentiallyStale { .. } | Self::Invalidated { .. }
        )
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Metadata Types
// ─────────────────────────────────────────────────────────────────────────────

/// Metadata associated with a memory.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Metadata {
    /// Source file path (for file content).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_path: Option<String>,

    /// Source URL (for web content).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub source_url: Option<String>,

    /// Associated session ID.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,

    /// Line range in source file.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub line_range: Option<(u32, u32)>,

    /// Tool name (for tool use memories).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tool_name: Option<String>,

    /// Subject entity for contradiction detection (e.g., "user.preferred_model").
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subject: Option<String>,

    /// Predicate/attribute for contradiction detection (e.g., "is").
    #[serde(skip_serializing_if = "Option::is_none")]
    pub predicate: Option<String>,

    /// Content hash for deduplication.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_hash: Option<String>,

    /// Tags for categorization.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub tags: Vec<String>,

    /// Additional custom fields.
    #[serde(flatten)]
    pub extra: serde_json::Map<String, serde_json::Value>,
}

/// A stored memory unit.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Memory {
    /// Unique identifier.
    pub id: MemoryId,

    /// Session this memory belongs to (foreign key to sessions table).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub session_id: Option<String>,

    /// Type of content.
    pub content_type: ContentType,

    /// The actual content text.
    pub content: String,

    /// Associated metadata.
    pub metadata: Metadata,

    /// When this memory was created.
    pub created_at: DateTime<Utc>,

    /// When this memory was last accessed.
    pub accessed_at: DateTime<Utc>,

    /// Access count for importance scoring.
    pub access_count: u32,

    /// Confidence metadata for ranking and cache invalidation.
    pub confidence: MemoryConfidence,

    /// Citation tracking for provenance and staleness detection.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub citation: Option<Citation>,
}

impl Memory {
    /// Create a new memory with the given content.
    pub fn new(content_type: ContentType, content: impl Into<String>) -> Self {
        let now = Utc::now();
        Self {
            id: MemoryId::new(),
            session_id: None,
            content_type,
            content: content.into(),
            metadata: Metadata::default(),
            created_at: now,
            accessed_at: now,
            access_count: 0,
            confidence: MemoryConfidence::default(),
            citation: None,
        }
    }

    /// Set the session ID for this memory.
    pub fn with_session(mut self, session_id: impl Into<String>) -> Self {
        self.session_id = Some(session_id.into());
        self
    }

    /// Set the confidence source for this memory.
    pub fn with_confidence(mut self, confidence: MemoryConfidence) -> Self {
        self.confidence = confidence;
        self
    }

    /// Set metadata for this memory.
    pub fn with_metadata(mut self, metadata: Metadata) -> Self {
        self.metadata = metadata;
        self
    }

    /// Add a tag to this memory.
    pub fn with_tag(mut self, tag: impl Into<String>) -> Self {
        self.metadata.tags.push(tag.into());
        self
    }

    /// Set the citation for this memory.
    pub fn with_citation(mut self, citation: Citation) -> Self {
        self.citation = Some(citation);
        self
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Session Types
// ─────────────────────────────────────────────────────────────────────────────

/// Unique identifier for a session.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct SessionId(pub Uuid);

impl SessionId {
    /// Generate a new random session ID.
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }

    /// Create from an existing UUID.
    pub fn from_uuid(uuid: Uuid) -> Self {
        Self(uuid)
    }

    /// Parse from a string.
    pub fn parse(s: &str) -> Result<Self, uuid::Error> {
        Ok(Self(Uuid::parse_str(s)?))
    }
}

impl Default for SessionId {
    fn default() -> Self {
        Self::new()
    }
}

impl std::fmt::Display for SessionId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// A conversation session.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Session {
    /// Unique identifier.
    pub id: SessionId,

    /// Optional title for the session.
    pub title: Option<String>,

    /// When this session was created.
    pub created_at: DateTime<Utc>,

    /// When this session was last updated.
    pub updated_at: DateTime<Utc>,
}

impl Session {
    /// Create a new session.
    pub fn new() -> Self {
        let now = Utc::now();
        Self {
            id: SessionId::new(),
            title: None,
            created_at: now,
            updated_at: now,
        }
    }

    /// Create a session with a title.
    pub fn with_title(mut self, title: impl Into<String>) -> Self {
        self.title = Some(title.into());
        self
    }
}

impl Default for Session {
    fn default() -> Self {
        Self::new()
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Note Types
// ─────────────────────────────────────────────────────────────────────────────

/// Unique identifier for a note.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct NoteId(pub Uuid);

impl NoteId {
    /// Generate a new random note ID.
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }

    /// Create from an existing UUID.
    pub fn from_uuid(uuid: Uuid) -> Self {
        Self(uuid)
    }

    /// Parse from a string.
    pub fn parse(s: &str) -> Result<Self, uuid::Error> {
        Ok(Self(Uuid::parse_str(s)?))
    }
}

impl Default for NoteId {
    fn default() -> Self {
        Self::new()
    }
}

impl std::fmt::Display for NoteId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// A user or agent note.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Note {
    /// Unique identifier.
    pub id: NoteId,

    /// Optional title.
    pub title: Option<String>,

    /// Note content.
    pub content: String,

    /// Tags for categorization.
    pub tags: Vec<String>,

    /// When this note was created.
    pub created_at: DateTime<Utc>,

    /// When this note was last updated.
    pub updated_at: DateTime<Utc>,
}

impl Note {
    /// Create a new note with the given content.
    pub fn new(content: impl Into<String>) -> Self {
        let now = Utc::now();
        Self {
            id: NoteId::new(),
            title: None,
            content: content.into(),
            tags: Vec::new(),
            created_at: now,
            updated_at: now,
        }
    }

    /// Set a title for this note.
    pub fn with_title(mut self, title: impl Into<String>) -> Self {
        self.title = Some(title.into());
        self
    }

    /// Add a tag to this note.
    pub fn with_tag(mut self, tag: impl Into<String>) -> Self {
        self.tags.push(tag.into());
        self
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Entity Types (for future knowledge graph)
// ─────────────────────────────────────────────────────────────────────────────

/// Unique identifier for an entity in the knowledge graph.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct EntityId(pub Uuid);

impl EntityId {
    /// Generate a new random entity ID.
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }

    /// Create from an existing UUID.
    pub fn from_uuid(uuid: Uuid) -> Self {
        Self(uuid)
    }

    /// Parse from a string.
    pub fn parse(s: &str) -> Result<Self, uuid::Error> {
        Ok(Self(Uuid::parse_str(s)?))
    }
}

impl Default for EntityId {
    fn default() -> Self {
        Self::new()
    }
}

impl std::fmt::Display for EntityId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// An entity in the knowledge graph.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Entity {
    /// Unique identifier.
    pub id: EntityId,

    /// Entity type/label (e.g., "Person", "Project", "Concept").
    pub label: String,

    /// Display name.
    pub name: String,

    /// Properties as key-value pairs.
    pub properties: serde_json::Map<String, serde_json::Value>,

    /// When this entity was created.
    pub created_at: DateTime<Utc>,

    /// When this entity was last updated.
    pub updated_at: DateTime<Utc>,
}

impl Entity {
    /// Create a new entity with the given label and name.
    pub fn new(label: impl Into<String>, name: impl Into<String>) -> Self {
        let now = Utc::now();
        Self {
            id: EntityId::new(),
            label: label.into(),
            name: name.into(),
            properties: serde_json::Map::new(),
            created_at: now,
            updated_at: now,
        }
    }

    /// Set a property on this entity.
    pub fn with_property(
        mut self,
        key: impl Into<String>,
        value: impl Into<serde_json::Value>,
    ) -> Self {
        self.properties.insert(key.into(), value.into());
        self
    }
}

// ─────────────────────────────────────────────────────────────────────────────
// Tests
// ─────────────────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_memory_id_roundtrip() {
        let id = MemoryId::new();
        let s = id.to_string();
        let parsed = MemoryId::parse(&s).unwrap();
        assert_eq!(id, parsed);
    }

    #[test]
    fn test_content_type_roundtrip() {
        for ct in [
            ContentType::UserMessage,
            ContentType::AssistantMessage,
            ContentType::ToolUse,
            ContentType::FileContent,
            ContentType::Note,
            ContentType::Fact,
            ContentType::WebContent,
            ContentType::Thought,
            ContentType::Summary,
        ] {
            let s = ct.as_str();
            let parsed = ContentType::from_str(s).unwrap();
            assert_eq!(ct, parsed);
        }
    }

    #[test]
    fn test_memory_builder() {
        // Note: with_metadata replaces all metadata, so set it first then add tags
        let memory = Memory::new(ContentType::Note, "Test note")
            .with_metadata(Metadata {
                source_path: Some("/path/to/file".into()),
                ..Default::default()
            })
            .with_tag("important");

        assert_eq!(memory.content, "Test note");
        assert_eq!(memory.content_type, ContentType::Note);
        assert!(memory.metadata.tags.contains(&"important".to_string()));
        assert_eq!(
            memory.metadata.source_path,
            Some("/path/to/file".to_string())
        );
    }

    #[test]
    fn test_session_builder() {
        let session = Session::new().with_title("Test Session");
        assert_eq!(session.title, Some("Test Session".to_string()));
    }

    #[test]
    fn test_note_builder() {
        let note = Note::new("Note content")
            .with_title("My Note")
            .with_tag("research");

        assert_eq!(note.content, "Note content");
        assert_eq!(note.title, Some("My Note".to_string()));
        assert!(note.tags.contains(&"research".to_string()));
    }

    #[test]
    fn test_entity_builder() {
        let entity = Entity::new("Person", "Alice")
            .with_property("email", "alice@example.com")
            .with_property("age", 30);

        assert_eq!(entity.label, "Person");
        assert_eq!(entity.name, "Alice");
        assert_eq!(
            entity.properties.get("email"),
            Some(&serde_json::Value::String("alice@example.com".into()))
        );
    }

    #[test]
    fn test_confidence_source_roundtrip() {
        for src in [
            ConfidenceSource::Stated,
            ConfidenceSource::Observed,
            ConfidenceSource::Inferred,
            ConfidenceSource::System,
        ] {
            let s = src.as_str();
            let parsed = ConfidenceSource::from_db_str(s).unwrap();
            assert_eq!(src, parsed);
        }
    }

    #[test]
    fn test_confidence_default() {
        let conf = MemoryConfidence::default();
        assert_eq!(conf.source, ConfidenceSource::Inferred);
        assert_eq!(conf.reinforcement_count, 0);
        assert!(!conf.superseded);
        assert!(conf.superseded_by.is_none());
        assert_eq!(conf.score, 1.0);
    }

    #[test]
    fn test_confidence_with_source() {
        let conf = MemoryConfidence::with_source(ConfidenceSource::Stated);
        assert_eq!(conf.source, ConfidenceSource::Stated);
        assert_eq!(conf.score, 1.0);
    }

    #[test]
    fn test_memory_with_confidence() {
        let mem = Memory::new(ContentType::Fact, "API key is X")
            .with_confidence(MemoryConfidence::with_source(ConfidenceSource::Stated));
        assert_eq!(mem.confidence.source, ConfidenceSource::Stated);
    }

    #[test]
    fn test_base_scores() {
        assert_eq!(ConfidenceSource::Stated.base_score(), 1.0);
        assert_eq!(ConfidenceSource::System.base_score(), 0.9);
        assert_eq!(ConfidenceSource::Observed.base_score(), 0.7);
        assert_eq!(ConfidenceSource::Inferred.base_score(), 0.5);
    }

    #[test]
    fn test_compute_score_fresh_no_reinforcement() {
        let conf = MemoryConfidence::with_source(ConfidenceSource::Stated);
        let params = ConfidenceParams::default();
        let score = conf.compute_score(&params);
        // Stated base=1.0, reinforcement boost=1.0, staleness=1.0
        assert!((score - 1.0).abs() < 0.01);
    }

    #[test]
    fn test_compute_score_inferred_fresh() {
        let conf = MemoryConfidence::with_source(ConfidenceSource::Inferred);
        let params = ConfidenceParams::default();
        let score = conf.compute_score(&params);
        assert!((score - 0.5).abs() < 0.01);
    }

    #[test]
    fn test_compute_score_reinforcement_boost() {
        let mut conf = MemoryConfidence::with_source(ConfidenceSource::Inferred);
        conf.reinforcement_count = 5;
        let params = ConfidenceParams::default();
        let score = conf.compute_score(&params);
        // base=0.5, boost=min(1.0+0.5, 1.5)=1.5, staleness=1.0 → 0.75
        assert!((score - 0.75).abs() < 0.01);
    }

    #[test]
    fn test_compute_score_reinforcement_capped() {
        let mut conf = MemoryConfidence::with_source(ConfidenceSource::Inferred);
        conf.reinforcement_count = 100; // way over cap
        let params = ConfidenceParams::default();
        let score = conf.compute_score(&params);
        // boost capped at 1.5 → 0.5 * 1.5 = 0.75
        assert!((score - 0.75).abs() < 0.01);
    }

    #[test]
    fn test_compute_score_superseded() {
        let mut conf = MemoryConfidence::with_source(ConfidenceSource::Stated);
        conf.superseded = true;
        let params = ConfidenceParams::default();
        assert_eq!(conf.compute_score(&params), 0.0);
    }

    #[test]
    fn test_compute_score_stale() {
        let mut conf = MemoryConfidence::with_source(ConfidenceSource::Stated);
        // Set last_accessed to 365 days ago (at or past staleness_days)
        conf.last_accessed = Utc::now() - chrono::Duration::days(365);
        let params = ConfidenceParams::default();
        let score = conf.compute_score(&params);
        // Should be at or near the floor: 1.0 * 1.0 * 0.3 = 0.3
        assert!((score - 0.3).abs() < 0.05);
    }

    #[test]
    fn test_compute_score_half_stale() {
        let mut conf = MemoryConfidence::with_source(ConfidenceSource::Stated);
        // Midpoint of decay: fresh_days=30, staleness_days=365, midpoint ~197 days
        conf.last_accessed = Utc::now() - chrono::Duration::days(197);
        let params = ConfidenceParams::default();
        let score = conf.compute_score(&params);
        // Should be roughly halfway between 1.0 and 0.3 ≈ 0.65
        assert!(score > 0.5 && score < 0.8, "score was {}", score);
    }

    #[test]
    fn test_compute_score_clamped_to_1() {
        // High base + high reinforcement should clamp to 1.0
        let mut conf = MemoryConfidence::with_source(ConfidenceSource::Stated);
        conf.reinforcement_count = 10;
        let params = ConfidenceParams {
            reinforcement_cap: 2.0, // allow higher cap
            ..Default::default()
        };
        let score = conf.compute_score(&params);
        assert_eq!(score, 1.0);
    }

    #[test]
    fn test_confidence_params_default() {
        let params = ConfidenceParams::default();
        assert_eq!(params.fresh_days, 30.0);
        assert_eq!(params.staleness_days, 365.0);
        assert_eq!(params.staleness_floor, 0.3);
        assert_eq!(params.reinforcement_cap, 1.5);
    }

    #[test]
    fn test_metadata_serialization() {
        let metadata = Metadata {
            source_path: Some("/test".into()),
            tags: vec!["a".into(), "b".into()],
            ..Default::default()
        };

        let json = serde_json::to_string(&metadata).unwrap();
        let parsed: Metadata = serde_json::from_str(&json).unwrap();

        assert_eq!(parsed.source_path, metadata.source_path);
        assert_eq!(parsed.tags, metadata.tags);
    }

    // ─────────────────────────────────────────────────────────────────────────
    // Citation Tests
    // ─────────────────────────────────────────────────────────────────────────

    #[test]
    fn test_citation_session() {
        let citation = Citation::session("session-123", 5);
        assert_eq!(citation.citation_type(), "session");
        if let Citation::Session {
            session_id,
            message_index,
            ..
        } = citation
        {
            assert_eq!(session_id, "session-123");
            assert_eq!(message_index, 5);
        } else {
            panic!("Expected Session citation");
        }
    }

    #[test]
    fn test_citation_file() {
        let citation = Citation::file("/path/to/file.rs");
        assert_eq!(citation.citation_type(), "file");
        if let Citation::File { path, .. } = citation {
            assert_eq!(path.to_str(), Some("/path/to/file.rs"));
        } else {
            panic!("Expected File citation");
        }
    }

    #[test]
    fn test_citation_web() {
        let citation = Citation::web("https://example.com");
        assert_eq!(citation.citation_type(), "web");
        if let Citation::Web { url, .. } = citation {
            assert_eq!(url, "https://example.com");
        } else {
            panic!("Expected Web citation");
        }
    }

    #[test]
    fn test_citation_user() {
        let citation = Citation::user("session-456");
        assert_eq!(citation.citation_type(), "user");
        if let Citation::User { session_id, .. } = citation {
            assert_eq!(session_id, "session-456");
        } else {
            panic!("Expected User citation");
        }
    }

    #[test]
    fn test_citation_system() {
        let citation = Citation::system("llm_extraction");
        assert_eq!(citation.citation_type(), "system");
        if let Citation::System { method, .. } = citation {
            assert_eq!(method, "llm_extraction");
        } else {
            panic!("Expected System citation");
        }
    }

    #[test]
    fn test_citation_serialization() {
        let citation = Citation::Session {
            session_id: "test-session".to_string(),
            message_index: 10,
            timestamp: Utc::now(),
        };

        let json = serde_json::to_string(&citation).unwrap();
        assert!(json.contains("\"type\":\"session\""));
        assert!(json.contains("\"session_id\":\"test-session\""));
        assert!(json.contains("\"message_index\":10"));

        let parsed: Citation = serde_json::from_str(&json).unwrap();
        if let Citation::Session {
            session_id,
            message_index,
            ..
        } = parsed
        {
            assert_eq!(session_id, "test-session");
            assert_eq!(message_index, 10);
        } else {
            panic!("Expected Session citation after deserialization");
        }
    }

    #[test]
    fn test_memory_with_citation() {
        let memory = Memory::new(ContentType::Fact, "Rust is fast")
            .with_citation(Citation::session("sess-1", 0));
        assert!(memory.citation.is_some());
        if let Some(Citation::Session { session_id, .. }) = memory.citation {
            assert_eq!(session_id, "sess-1");
        }
    }

    #[test]
    fn test_staleness_methods() {
        assert!(Staleness::Fresh.is_fresh());
        assert!(!Staleness::Fresh.is_stale());

        let stale = Staleness::PotentiallyStale {
            reason: "test".to_string(),
            last_verified: None,
        };
        assert!(!stale.is_fresh());
        assert!(stale.is_stale());

        let invalid = Staleness::Invalidated {
            reason: "test".to_string(),
            detected_at: Utc::now(),
        };
        assert!(!invalid.is_fresh());
        assert!(invalid.is_stale());

        assert!(!Staleness::Unknown.is_fresh());
        assert!(!Staleness::Unknown.is_stale());
    }
}
